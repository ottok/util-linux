From: Karel Zak <kzak@redhat.com>
Date: Tue, 16 Apr 2024 10:49:31 +0200
Subject: libsmartcols: reset wrap after calculation

Fixes: https://github.com/util-linux/util-linux/issues/2956
Signed-off-by: Karel Zak <kzak@redhat.com>
(cherry picked from commit 62f64717ec134b10c5a670403c2d8c43b608e671)
---
 libsmartcols/src/calculate.c |  7 +++++--
 libsmartcols/src/print.c     | 20 +++++++++++++-------
 2 files changed, 18 insertions(+), 9 deletions(-)

diff --git a/libsmartcols/src/calculate.c b/libsmartcols/src/calculate.c
index 84198da..deabb07 100644
--- a/libsmartcols/src/calculate.c
+++ b/libsmartcols/src/calculate.c
@@ -413,10 +413,8 @@ int __scols_calculate(struct libscols_table *tb, struct ul_buffer *buf)
 	size_t colsepsz;
 	int sorted = 0;
 
-
 	DBG(TAB, ul_debugobj(tb, "-----calculate-(termwidth=%zu)-----", tb->termwidth));
 	tb->is_dummy_print = 1;
-
 	colsepsz = scols_table_is_noencoding(tb) ?
 			mbs_width(colsep(tb)) :
 			mbs_safe_width(colsep(tb));
@@ -430,6 +428,11 @@ int __scols_calculate(struct libscols_table *tb, struct ul_buffer *buf)
 	while (scols_table_next_column(tb, &itr, &cl) == 0) {
 		int is_last;
 
+		memset(&cl->wstat, 0, sizeof(cl->wstat));
+		cl->width = 0;
+		cl->width_treeart = 0;
+		scols_column_reset_wrap(cl);
+
 		if (scols_column_is_hidden(cl))
 			continue;
 
diff --git a/libsmartcols/src/print.c b/libsmartcols/src/print.c
index 88ab5a2..ab279e3 100644
--- a/libsmartcols/src/print.c
+++ b/libsmartcols/src/print.c
@@ -764,11 +764,11 @@ notree:
 		}
 	}
 
+done:
 	/* reset wrapping after greatest chunk calculation */
 	if (cal && scols_column_is_wrap(cl))
 		scols_column_reset_wrap(cl);
 
-done:
 	DBG(COL, ul_debugobj(cl, "__cursor_to_buffer rc=%d", rc));
 	return rc;
 }
@@ -802,8 +802,12 @@ static int print_line(struct libscols_table *tb,
 		rc = __cursor_to_buffer(tb, buf, 0);
 		if (!rc)
 			rc = print_data(tb, buf);
-		if (!rc && scols_column_has_pending_wrap(cl))
-			pending = 1;
+		if (!rc) {
+			if (scols_column_has_pending_wrap(cl))
+				pending = 1;
+			else
+				scols_column_reset_wrap(cl);
+		}
 		scols_table_reset_cursor(tb);
 	}
 	fputs_color_line_close(tb);
@@ -827,10 +831,12 @@ static int print_line(struct libscols_table *tb,
 				rc = __cursor_to_buffer(tb, buf, 0);
 				if (!rc)
 					rc = print_pending_data(tb, buf);
-				if (!rc && scols_column_has_pending_wrap(cl))
-					pending = 1;
-				if (!rc && !pending)
-					scols_column_reset_wrap(cl);
+				if (!rc) {
+					if (scols_column_has_pending_wrap(cl))
+						pending = 1;
+					else
+						scols_column_reset_wrap(cl);
+				}
 			} else
 				print_empty_cell(tb, cl, ln, NULL, ul_buffer_get_bufsiz(buf));
 			scols_table_reset_cursor(tb);
