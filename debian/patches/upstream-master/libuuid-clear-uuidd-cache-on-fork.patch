From: =?utf-8?q?Thomas_Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Tue, 7 May 2024 13:44:31 +0200
Subject: libuuid: clear uuidd cache on fork()
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

After fork() the memory of the calling thread is preserved into the new
process. This also includes TLS.
Make sure to reset the cache after a fork to avoid reuse of cached
values.

Only the TLS of the thread calling fork() is relevant as that is the
only thread that gets forked.
New threads will received newly initialized TLS.

Fixes https://github.com/util-linux/util-linux/issues/3009
Signed-off-by: Thomas Wei√üschuh <thomas@t-8ch.de>
---
 libuuid/src/Makemodule.am |  2 +-
 libuuid/src/gen_uuid.c    | 17 +++++++++++++++--
 2 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/libuuid/src/Makemodule.am b/libuuid/src/Makemodule.am
index e58fa26..417fd2b 100644
--- a/libuuid/src/Makemodule.am
+++ b/libuuid/src/Makemodule.am
@@ -31,7 +31,7 @@ libuuid_la_SOURCES = \
 EXTRA_libuuid_la_DEPENDENCIES = \
 	libuuid/src/libuuid.sym
 
-libuuid_la_LIBADD       = $(LDADD) $(SOCKET_LIBS)
+libuuid_la_LIBADD       = $(LDADD) $(SOCKET_LIBS) -lpthread
 
 libuuid_la_CFLAGS = \
 	$(AM_CFLAGS) \
diff --git a/libuuid/src/gen_uuid.c b/libuuid/src/gen_uuid.c
index c40f9d6..3b76ddc 100644
--- a/libuuid/src/gen_uuid.c
+++ b/libuuid/src/gen_uuid.c
@@ -80,6 +80,8 @@
 #if defined(__linux__) && defined(HAVE_SYS_SYSCALL_H)
 #include <sys/syscall.h>
 #endif
+#include <pthread.h>
+#include <signal.h>
 
 #include "all-io.h"
 #include "uuidP.h"
@@ -591,9 +593,21 @@ THREAD_LOCAL struct {
 	.cache_size = CS_MIN,
 };
 
+static void reset_uuidd_cache(void)
+{
+	memset(&uuidd_cache, 0, sizeof(uuidd_cache));
+	uuidd_cache.cache_size = CS_MIN;
+}
+
 static int uuid_generate_time_generic(uuid_t out) {
+	static volatile sig_atomic_t atfork_registered;
 	time_t	now;
 
+	if (!atfork_registered) {
+		pthread_atfork(NULL, NULL, reset_uuidd_cache);
+		atfork_registered = 1;
+	}
+
 	if (uuidd_cache.num > 0) { /* expire cache */
 		now = time(NULL);
 		if (now > uuidd_cache.last_time+1) {
@@ -622,8 +636,7 @@ static int uuid_generate_time_generic(uuid_t out) {
 			return 0;
 		}
 		/* request to daemon failed, reset cache */
-		uuidd_cache.num = 0;
-		uuidd_cache.cache_size = CS_MIN;
+		reset_uuidd_cache();
 	}
 	if (uuidd_cache.num > 0) { /* serve uuid from cache */
 		uuidd_cache.uu.time_low++;
